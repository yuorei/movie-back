package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/yuorei/video-server/graph/generated"
	"github.com/yuorei/video-server/graph/model"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, input model.UploadVideo) (*model.Video, error) {
	// 一時的なMP4ファイルのパスを生成
	tempDir := "temp"
	os.MkdirAll(tempDir, 0755)
	tempMp4 := filepath.Join(tempDir, input.Video.Filename)

	// 一時ファイルの作成
	tempFile, err := os.Create(tempMp4)
	if err != nil {
		return nil, err
	}
	defer tempFile.Close()

	// アップロードされたファイルの内容を一時ファイルにコピー
	_, err = io.Copy(tempFile, input.Video.File)
	if err != nil {
		return nil, err
	}

	// HLS変換の実行
	outputDir := "output"
	os.MkdirAll(outputDir, 0755)
	uuidObj, err := uuid.NewUUID()
	if err != nil {
		return nil, fmt.Errorf("failed to generate uuid: %w", err)
	}

	output := "output_" + uuidObj.String() + ".m3u8"
	outputHLS := filepath.Join(outputDir, output)
	cmd := exec.Command("ffmpeg", "-i", tempMp4, "-codec:", "copy", "-start_number", "0", "-hls_time", "10", "-hls_list_size", "0", "-f", "hls", outputHLS)
	log.Println(cmd.Args)
	result, err := cmd.CombinedOutput()
	log.Println(string(result))
	if err != nil {
		return nil, fmt.Errorf("failed to execute ffmpeg command: %w", err)
	}

	// 一時ファイルの削除
	os.Remove(tempMp4)

	// TODO ストレージサービスに保存する
	err = filepath.Walk("output", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 対象のファイルかどうかを確認します
		if strings.HasPrefix(filepath.Base(path), "output_"+uuidObj.String()) && (strings.HasSuffix(path, ".m3u8") || strings.HasSuffix(path, ".ts")) {
			err := os.Remove(path)
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to remove output files: %w", err)
	}

	return &model.Video{
		ID:    uuidObj.String(),
		Title: input.Title,
		Uploader: &model.User{
			ID: uuid.NewString(),
			// TODO Userの名前を取得する
		},
		// TODO URLを修正する
		VideoURL:    output,
		CreatedAt:   time.Now().String(),
		UpdatedAt:   time.Now().String(),
		Description: input.Description,
		// TODO URLを修正する
		ThumbnailImageURL: output,
	}, nil
}

// ID is the resolver for the id field.
func (r *videoResolver) ID(ctx context.Context, obj *model.Video) (string, error) {
	return fmt.Sprintf("video%s%s", "_", obj.ID), nil
}

// Uploader is the resolver for the uploader field.
func (r *videoResolver) Uploader(ctx context.Context, obj *model.Video) (*model.User, error) {
	return &model.User{
		ID:   obj.Uploader.ID,
		Name: obj.Uploader.Name,
	}, nil
}

// Video returns generated.VideoResolver implementation.
func (r *Resolver) Video() generated.VideoResolver { return &videoResolver{r} }

type videoResolver struct{ *Resolver }
